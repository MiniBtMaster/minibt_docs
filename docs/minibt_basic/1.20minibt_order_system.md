# **minibt量化交易：订单系统介绍** 

## 一、系统概述

MiniBT 订单系统是一个统一回测与实盘的交易执行框架，采用分层设计理念，将策略层、订单管理层和交易执行层分离，支持多种订单类型和灵活的交易控制。

### 设计理念

1. **统一接口**：策略无需区分回测与实盘，统一使用 `buy()` 和 `sell()` 方法
2. **灵活订单类型**：支持市价单、限价单、止损单、止损限价单等多种订单
3. **完整生命周期管理**：订单从创建到完成的全流程跟踪
4. **风险控制**：内置手数校验、资金校验和止损机制


### 功能特性

1. **价格跳空处理**：支持考虑K线最高最低价进行订单触发判断
2. **部分成交支持**：订单可分批次成交，支持Partial状态
3. **完善有效期管理**：支持多种有效期类型（整数周期、绝对时间、时间间隔）
4. **订单状态跟踪**：完整的订单生命周期管理和状态转换
5. **OCO订单增强**：支持多个关联订单的相互取消
6. **统计与查询**：丰富的订单查询和统计功能

## 二、核心组件

### 1. 订单类 (Order)
```python
@dataclass
class Order:
    # 基础信息
    create_time: Optional[datetime.datetime]  # 创建时间
    side: OrderSide                          # 买入/卖出
    size: int                                # 手数
    
    # 订单类型
    exectype: OrderType = OrderType.Market   # 订单类型
    price: Optional[float] = None           # 委托价格
    pricelimit: Optional[float] = None      # 止损限价单限价
    
    # 有效期控制
    valid: Optional[Union[datetime.datetime, datetime.timedelta, int]] = None
    
    # 状态跟踪
    status: OrderStatus = OrderStatus.Created
    executed_price: Optional[float] = None  # 成交价格
    executed_size: int = 0                  # 已成交手数
```

### 2. 订单管理器 (Broker)
作为 KLine 与 BtAccount 之间的桥梁，负责：

- 订单创建、执行和状态管理
- 资金校验和仓位更新
- 手续费和保证金计算
- 止损止盈管理

### 3. 策略接口层
提供统一的 `buy()` 和 `sell()` 方法，自动区分回测和实盘模式。

## 三、订单类型详解

### 1. 市价单 (Market)
```python
# 当前K线开盘价买入
order = self.buy(size=10, exectype=OrderType.Market)

# 下一根K线开盘价买入（bar参数控制）
order = self.buy(size=10, exectype=OrderType.Market, bar=1)
```

### 2. 收盘价单 (Close)
```python
# 当前K线收盘价买入
order = self.buy(size=10, exectype=OrderType.Close)

# 下一根K线收盘价买入
order = self.buy(size=10, exectype=OrderType.Close, bar=1)
```

### 3. 限价单 (Limit)
```python
# 低于当前价格的限价买入单
order = self.buy(
    size=10,
    exectype=OrderType.Limit,
    price=3800,  # 委托价格
    valid=5      # 有效期5个K线周期
)
```

### 4. 止损单 (Stop)
```python
# 突破3800买入的止损单
order = self.buy(
    size=10,
    exectype=OrderType.Stop,
    price=3800,  # 触发价格
    valid=datetime.timedelta(days=3)  # 有效期3天
)
```

### 5. 止损限价单 (StopLimit)
```python
# 止损触发后转为限价单
order = self.buy(
    size=10,
    exectype=OrderType.StopLimit,
    price=3800,      # 触发价格
    pricelimit=3810  # 限价价格
)
```
<!-- 
## **四、使用示例**

### 示例1：简单移动平均线策略
```python
class SMAStrategy(Strategy):
    def next(self):
        # 计算指标
        ma_fast = self.sma(period=5)
        ma_slow = self.sma(period=20)
        
        # 金叉买入
        if crossover(ma_fast, ma_slow):
            # 市价买入10手
            order = self.buy(size=10)
            print(f"创建买入订单: {order.to_dict()}")
        
        # 死叉卖出
        elif crossunder(ma_fast, ma_slow):
            # 市价卖出全部持仓
            if self.position > 0:
                order = self.sell(size=self.position)
                print(f"创建卖出订单: {order.to_dict()}")
```

### 示例2：带止损的突破策略
```python
class BreakoutStrategy(Strategy):
    def next(self):
        # 突破前高买入
        prev_high = self.kline.high.ref[-20:-1]  # 前20周期最高价
        
        if self.close.new > prev_high:
            # 限价单买入，价格设为突破价
            buy_order = self.buy(
                size=5,
                exectype=OrderType.Limit,
                price=prev_high * 1.01,  # 突破后1%价格买入
                valid=3  # 有效期3个周期
            )
            
            # 设置止损订单（OCO：One Cancel Others）
            stop_price = prev_high * 0.98
            stop_order = self.sell(
                size=5,
                exectype=OrderType.Stop,
                price=stop_price,
                oco=buy_order  # OCO关联
            )
```

### 示例3：分批建仓与部分成交策略
```python
class ScaleInWithPartialStrategy(Strategy):
    """分批建仓，支持部分成交的策略"""
    
    def init(self):
        self.entry_prices = [3800, 3750, 3700]  # 分批建仓价格
        self.order_refs = []  # 跟踪订单引用
        
    def next(self):
        current_price = self.close[0]
        
        # 分批创建限价订单
        for i, target_price in enumerate(self.entry_prices):
            if i >= len(self.order_refs) and current_price <= target_price:
                # 创建限价买入订单
                order = self.buy(
                    size=3,
                    exectype=OrderType.Limit,
                    price=target_price,
                    valid=3,  # 有效期3个周期
                    bar=0
                )
                
                if order:
                    self.order_refs.append(order.ref)
                    print(f"创建限价订单: 价格={target_price}, 手数=3, ref={order.ref}")
        
        # 监控订单状态
        self.monitor_partial_orders()
    
    def monitor_partial_orders(self):
        """监控部分成交订单"""
        broker = self.data._broker
        
        for ref in list(self.order_refs):
            order = broker.get_order(ref)
            
            if order and order.status == OrderStatus.Partial:
                print(f"订单部分成交: ref={order.ref}, "
                      f"已成交={order.executed_size}, 剩余={order.remaining}")
                
                # 如果部分成交，可以调整剩余订单的价格
                if order.remaining > 0 and 'price_adjusted' not in order.info:
                    new_price = order.price * 0.99  # 将剩余订单价格下调1%
                    
                    # 创建新的限价单用于剩余手数
                    new_order = self.buy(
                        size=order.remaining,
                        exectype=OrderType.Limit,
                        price=new_price,
                        valid=order.valid,
                        bar=0
                    )
                    
                    if new_order:
                        order.info['price_adjusted'] = True
                        order.info['child_order'] = new_order.ref
                        self.order_refs.append(new_order.ref)
                        print(f"创建调整订单: 新价格={new_price}, ref={new_order.ref}")
```

### 示例4：订单状态监控
```python
class OrderTrackingStrategy(Strategy):
    def init(self):
        self.active_orders = []
    
    def next(self):
        # 创建新订单
        if self.should_buy():
            order = self.buy(size=10, exectype=OrderType.Limit, price=3800)
            self.active_orders.append(order)
        
        # 监控订单状态
        for order in self.active_orders.copy():
            if order.is_completed:
                print(f"订单完成: {order.to_dict()}")
                self.active_orders.remove(order)
            elif order.is_canceled:
                print(f"订单取消: {order.to_dict()}")
                self.active_orders.remove(order)
            elif not order.is_active:
                print(f"订单失效: {order.to_dict()}")
                self.active_orders.remove(order)
```
### 示例5：高级订单管理（止损、限价、OCO等）
```python
class AdvancedOrderStrategy(Strategy):
    def next(self):
        # 在价格低于某值时创建限价买入单，同时设置止损和止盈（OCO订单组）
        if self.close[0] < 3500:
            # 限价买入单
            buy_order = self.buy(
                size=5,
                exectype=OrderType.Limit,
                price=3450,
                valid=5
            )
            
            # 止损单（OCO关联买入单）
            stop_loss_order = self.sell(
                size=5,
                exectype=OrderType.Stop,
                price=3400,
                oco=buy_order,
                valid=10
            )
            
            # 止盈单（OCO关联买入单）
            take_profit_order = self.sell(
                size=5,
                exectype=OrderType.Limit,
                price=3600,
                oco=buy_order,
                valid=10
            )
            
            # 记录订单组
            self.order_group = [buy_order, stop_loss_order, take_profit_order]
```
### 示例6：订单有效期管理
```python
class OrderExpiryStrategy(Strategy):
    def next(self):
        # 使用不同类型的有效期
        
        # 1. 整数有效期（K线周期数）
        order1 = self.buy(
            size=5,
            exectype=OrderType.Limit,
            price=3500,
            valid=3  # 3个K线周期后过期
        )
        
        # 2. 绝对时间有效期
        from datetime import datetime
        expiry_time = datetime(2024, 12, 31, 15, 0, 0)
        order2 = self.sell(
            size=5,
            exectype=OrderType.Limit,
            price=3600,
            valid=expiry_time  # 指定日期时间过期
        )
        
        # 3. 时间间隔有效期
        from datetime import timedelta
        order3 = self.buy(
            size=5,
            exectype=OrderType.Market,
            valid=timedelta(hours=24)  # 24小时后过期
        )
```

### 示例7：订单查询和统计

```python
class OrderQueryStrategy(Strategy):
    def next(self):
        # 创建订单
        if self.some_condition():
            self.buy(size=2, exectype=OrderType.Limit, price=3500)
        
        # 查询订单
        broker = self.data._broker
        
        # 获取所有订单
        all_orders = broker.get_orders()
        
        # 按状态查询
        active_orders = broker.get_orders(OrderStatus.Active)
        completed_orders = broker.get_orders(OrderStatus.Completed)
        
        # 按方向查询
        buy_orders = broker.get_orders_by_side(OrderSide.Buy)
        sell_orders = broker.get_orders_by_side(OrderSide.Sell)
        
        # 按类型查询
        limit_orders = broker.get_orders_by_type(OrderType.Limit)
        
        # 获取订单统计
        stats = broker.get_order_statistics()
        print(f"订单统计: {stats}")
        
        # 取消所有活跃订单
        for order in active_orders:
            broker.cancel_order(order, "策略取消")
```

### 示例8：高级OCO订单组（止损+止盈）

```python
class OCOOrderGroupStrategy(Strategy):
    """复杂的OCO订单组管理策略"""
    
    def init(self):
        self.position_entry = None  # 入场价格
        self.order_group = {}  # 订单组: {group_id: [order_refs]}
        self.group_counter = 0
    
    def next(self):
        current_price = self.close[0]
        
        # 入场条件：金叉信号
        if self.crossover(self.sma(5), self.sma(20)) and self.position == 0:
            self.position_entry = current_price
            
            # 创建主入场订单
            entry_order = self.buy(
                size=5,
                exectype=OrderType.Market,
                bar=1
            )
            
            if entry_order:
                group_id = f"group_{self.group_counter}"
                self.group_counter += 1
                
                # 创建OCO订单组：止损+止盈
                self.create_oco_group(group_id, entry_order, current_price)
    
    def create_oco_group(self, group_id: str, entry_order: Order, entry_price: float):
        """创建OCO订单组"""
        # 计算止损和止盈价格
        stop_loss_price = entry_price * 0.95  # 5%止损
        take_profit_price = entry_price * 1.08  # 8%止盈
        
        # 止损订单
        stop_loss_order = self.sell(
            size=5,
            exectype=OrderType.Stop,
            price=stop_loss_price,
            oco=entry_order,  # 与入场订单关联
            valid=20  # 有效期20个周期
        )
        
        # 止盈订单
        take_profit_order = self.sell(
            size=5,
            exectype=OrderType.Limit,
            price=take_profit_price,
            oco=entry_order,  # 与入场订单关联
            valid=20  # 有效期20个周期
        )
        
        # 移动止损订单（追踪止损）
        trailing_stop_price = entry_price * 0.98  # 2%追踪止损
        trailing_stop_order = self.sell(
            size=5,
            exectype=OrderType.Stop,
            price=trailing_stop_price,
            valid=20
        )
        
        # 保存订单组
        self.order_group[group_id] = {
            'entry': entry_order.ref,
            'stop_loss': stop_loss_order.ref if stop_loss_order else None,
            'take_profit': take_profit_order.ref if take_profit_order else None,
            'trailing_stop': trailing_stop_order.ref if trailing_stop_order else None,
            'entry_price': entry_price,
            'created_time': self.data.current_time
        }
        
        print(f"创建OCO订单组 {group_id}: 入场={entry_price}, "
              f"止损={stop_loss_price}, 止盈={take_profit_price}")
    
    def update_trailing_stop(self, group_id: str, current_price: float):
        """更新追踪止损"""
        if group_id in self.order_group:
            group = self.order_group[group_id]
            entry_price = group['entry_price']
            
            # 计算新的追踪止损价格（移动至盈亏平衡点后开始追踪）
            if current_price > entry_price * 1.03:  # 盈利3%后启动追踪
                new_trailing_stop = current_price * 0.97
                
                # 取消旧的追踪止损
                old_ref = group['trailing_stop']
                if old_ref:
                    broker = self.data._broker
                    old_order = broker.get_order(old_ref)
                    if old_order:
                        broker.cancel_order(old_order, "更新追踪止损")
                
                # 创建新的追踪止损
                new_order = self.sell(
                    size=5,
                    exectype=OrderType.Stop,
                    price=new_trailing_stop,
                    valid=10
                )
                
                if new_order:
                    group['trailing_stop'] = new_order.ref
                    print(f"更新追踪止损: 新价格={new_trailing_stop}")
```

### 示例9：有效期管理策略

```python
class ExpiryManagementStrategy(Strategy):
    """订单有效期管理策略"""
    
    def init(self):
        self.orders_by_expiry = {}  # 按有效期分类的订单
    
    def next(self):
        current_time = self.data.current_time
        
        # 创建不同有效期的订单
        if self.some_buy_signal():
            # 短期订单：3个周期有效期
            short_term_order = self.buy(
                size=2,
                exectype=OrderType.Limit,
                price=self.close[0] * 0.99,
                valid=3,  # 3个周期
                bar=0
            )
            
            # 中期订单：绝对时间有效期
            expiry_date = current_time + datetime.timedelta(days=7)
            mid_term_order = self.buy(
                size=3,
                exectype=OrderType.Limit,
                price=self.close[0] * 0.98,
                valid=expiry_date,  # 到指定日期
                bar=0
            )
            
            # 长期订单：时间间隔有效期
            long_term_order = self.buy(
                size=4,
                exectype=OrderType.Limit,
                price=self.close[0] * 0.97,
                valid=datetime.timedelta(days=30),  # 30天
                bar=0
            )
            
            # 跟踪订单
            self.track_expiry_status(short_term_order, "短期")
            self.track_expiry_status(mid_term_order, "中期")
            self.track_expiry_status(long_term_order, "长期")
    
    def track_expiry_status(self, order: Order, category: str):
        """跟踪订单有效期状态"""
        if order:
            broker = self.data._broker
            
            # 获取剩余时间信息
            remaining_periods = order.get_remaining_valid_periods()
            expiry_time = order.get_expiry_time()
            
            info = {
                'category': category,
                'remaining_periods': remaining_periods,
                'expiry_time': expiry_time,
                'ref': order.ref
            }
            
            self.orders_by_expiry[order.ref] = info
            
            print(f"{category}订单创建: ref={order.ref}, "
                  f"剩余周期={remaining_periods}, "
                  f"过期时间={expiry_time}")
    
    def monitor_expiry_orders(self):
        """监控即将过期的订单"""
        current_time = self.data.current_time
        
        for ref, info in list(self.orders_by_expiry.items()):
            broker = self.data._broker
            order = broker.get_order(ref)
            
            if order and order.is_active:
                # 检查剩余时间
                remaining_periods = info['remaining_periods']
                expiry_time = info['expiry_time']
                
                # 根据剩余时间采取行动
                if remaining_periods == 1:  # 即将过期
                    print(f"警告: 订单 {ref} 将在下个周期过期")
                    
                    # 可以调整价格以增加成交机会
                    if order.exectype == OrderType.Limit:
                        # 将限价单价格调整为当前市价
                        new_price = self.data.current_close
                        order.price = new_price
                        print(f"调整订单价格至市价: {new_price}")
                
                elif remaining_periods == 0:  # 已过期
                    if order in broker._pending_orders:
                        print(f"订单 {ref} 已过期，自动取消")
```

### 示例10：订单统计与分析策略

```python
class OrderStatisticsStrategy(Strategy):
    """订单统计与分析策略"""
    
    def init(self):
        self.statistics_history = []  # 统计历史记录
        self.last_stat_time = None
    
    def next(self):
        current_time = self.data.current_time
        
        # 每10个周期记录一次统计
        if self.last_stat_time is None or (current_time - self.last_stat_time).total_seconds() > 86400:  # 每天
            self.collect_statistics()
            self.last_stat_time = current_time
    
    def collect_statistics(self):
        """收集订单统计信息"""
        broker = self.data._broker
        
        # 获取基础统计
        stats = broker.get_order_statistics()
        
        # 添加详细分析
        detailed_stats = self.analyze_orders(stats)
        
        # 保存历史
        self.statistics_history.append({
            'timestamp': self.data.current_time,
            'stats': detailed_stats
        })
        
        # 打印统计信息
        self.print_statistics(detailed_stats)
    
    def analyze_orders(self, base_stats: dict) -> dict:
        """分析订单数据"""
        broker = self.data._broker
        
        # 计算成交率
        total_attempted = base_stats['total_orders']
        total_completed = base_stats['completed_orders']
        completion_rate = total_completed / total_attempted if total_attempted > 0 else 0
        
        # 分析订单类型分布
        market_orders = len(broker.get_orders_by_type(OrderType.Market))
        limit_orders = len(broker.get_orders_by_type(OrderType.Limit))
        stop_orders = len(broker.get_orders_by_type(OrderType.Stop))
        
        # 分析订单生命周期
        avg_lifetime = self.calculate_avg_order_lifetime()
        
        return {
            **base_stats,
            'completion_rate': completion_rate,
            'market_orders': market_orders,
            'limit_orders': limit_orders,
            'stop_orders': stop_orders,
            'avg_order_lifetime': avg_lifetime,
            'order_type_distribution': {
                'market': market_orders,
                'limit': limit_orders,
                'stop': stop_orders
            }
        }
    
    def calculate_avg_order_lifetime(self) -> float:
        """计算订单平均生命周期"""
        broker = self.data._broker
        completed_orders = broker.get_completed_orders()
        
        if not completed_orders:
            return 0
        
        total_lifetime = 0
        for order in completed_orders:
            if order.create_time and order.executed_datetime:
                lifetime = (order.executed_datetime - order.create_time).total_seconds()
                total_lifetime += lifetime
        
        return total_lifetime / len(completed_orders)
    
    def print_statistics(self, stats: dict):
        """打印统计信息"""
        print(f"\n=== 订单统计 (时间: {self.data.current_time}) ===")
        print(f"总订单数: {stats['total_orders']}")
        print(f"活跃订单: {stats['active_orders']}")
        print(f"完成订单: {stats['completed_orders']} (成交率: {stats['completion_rate']:.1%})")
        print(f"取消订单: {stats['cancelled_orders']}")
        print(f"拒绝订单: {stats['rejected_orders']}")
        print(f"过期订单: {stats['expired_orders']}")
        print(f"订单类型分布: {stats['order_type_distribution']}")
        print(f"平均订单生命周期: {stats['avg_order_lifetime']:.1f} 秒")
        print(f"总成交金额: {stats['total_executed_value']:.2f}")
        print(f"总手续费: {stats['total_commission']:.2f}")
```

### 示例11：高级价格滑点模拟
```python
class SlippageSimulationStrategy(Strategy):
    """高级价格滑点模拟策略"""
    
    def init(self):
        # 滑点配置
        self.slippage_config = {
            'normal': 0.001,  # 正常市场: 0.1%滑点
            'volatile': 0.005,  # 高波动: 0.5%滑点
            'illiquid': 0.01,   # 低流动性: 1%滑点
        }
        
        self.market_state = 'normal'
    
    def next(self):
        # 分析市场状态
        self.analyze_market_state()
        
        # 根据市场状态调整订单
        if self.buy_signal():
            self.create_order_with_slippage()
    
    def analyze_market_state(self):
        """分析市场状态"""
        # 计算波动率
        returns = np.log(self.close / self.close.shift(1))
        volatility = returns.std() * np.sqrt(252)  # 年化波动率
        
        # 计算成交量变化
        volume_ratio = self.volume[0] / self.volume[-20:].mean()
        
        # 确定市场状态
        if volatility > 0.3:  # 高波动率
            self.market_state = 'volatile'
        elif volume_ratio < 0.5:  # 低成交量
            self.market_state = 'illiquid'
        else:
            self.market_state = 'normal'
    
    def create_order_with_slippage(self):
        """创建考虑滑点的订单"""
        current_price = self.close[0]
        slippage_rate = self.slippage_config[self.market_state]
        
        if self.market_state == 'normal':
            # 正常市场：使用限价单
            order_price = current_price * (1 + slippage_rate)
            order = self.buy(
                size=2,
                exectype=OrderType.Limit,
                price=order_price,
                valid=2
            )
            
        elif self.market_state == 'volatile':
            # 高波动市场：使用市价单+滑点估计
            estimated_price = current_price * (1 + slippage_rate)
            order = self.buy(
                size=1,  # 减小手数
                exectype=OrderType.Market,
                bar=0
            )
            
            print(f"高波动市场下单: 估计滑点={slippage_rate:.1%}, "
                  f"估计成交价={estimated_price:.2f}")
            
        elif self.market_state == 'illiquid':
            # 低流动性市场：使用更保守的策略
            # 拆分订单，分批执行
            for i in range(3):  # 分3批
                order_price = current_price * (1 + slippage_rate * (i + 1))
                order = self.buy(
                    size=1,
                    exectype=OrderType.Limit,
                    price=order_price,
                    valid=5
                )
                
                if order:
                    order.info['batch'] = i + 1
                    order.info['market_state'] = self.market_state
``` -->
## 五、订单生命周期

### 1. 创建阶段
```python
# 创建订单，初始状态为 Created
order = Order(
    create_time=datetime.now(),
    side=OrderSide.Buy,
    size=10,
    exectype=OrderType.Limit,
    price=3800
)
```

### 2. 提交阶段
```python
# 提交给 Broker，状态变为 Submitted
order.update_status(OrderStatus.Submitted)
```

### 3. 执行阶段
```python
# 订单成交，更新状态和成交信息
order.execute(
    price=3798.5,  # 成交价格
    size=10,       # 成交手数
    datetime=datetime.now(),
    value=37985.0,  # 成交金额
    commission=18.99  # 手续费
)
```

### 4. 完成阶段
```python
# 订单完成
order.update_status(OrderStatus.Completed)

```
### 5. 完整的订单状态转换图
```
Created → Submitted → Accepted → Partial/Completed
    ↓          ↓          ↓           ↓
Rejected   Canceled   Expired    Margin(保证金不足)
```

## 六、实盘与回测统一

### 回测模式
```python
# 回测时返回订单对象
order = self.buy(size=10, exectype=OrderType.Limit, price=3800)
print(f"回测订单: {order.ref}, 状态: {order.status}")
```

### 实盘模式
```python
# 实盘时返回浮动盈亏
float_profit = self.buy(size=10)
print(f"实盘买入，当前浮动盈亏: {float_profit}")

# 通过 TQSDK 的 TargetPosTask 设置目标仓位
# 系统自动处理订单拆单和成交
```

## 七、进阶功能

### 1. 订单有效期
```python
# 绝对时间有效期
order = self.buy(
    size=10,
    exectype=OrderType.Limit,
    price=3800,
    valid=datetime.datetime(2024, 12, 31, 15, 0, 0)  # 到2024年底
)

# 相对时间有效期（天数）
order = self.buy(
    size=10,
    exectype=OrderType.Limit,
    price=3800,
    valid=5  # 5天后过期
)

# 时间间隔有效期
order = self.buy(
    size=10,
    exectype=OrderType.Limit,
    price=3800,
    valid=datetime.timedelta(hours=24)  # 24小时后过期
)
```

### 2. OCO 订单 (One Cancel Others)
```python
# 创建主订单
main_order = self.buy(
    size=10,
    exectype=OrderType.Limit,
    price=3800
)

# 创建关联的止损订单
stop_order = self.sell(
    size=10,
    exectype=OrderType.Stop,
    price=3750,
    oco=main_order  # 一个成交，另一个自动取消
)
```

### 3. 订单查询和管理
```python
# 获取所有订单
all_orders = self.broker.get_orders()

# 按状态筛选
active_orders = self.broker.get_orders(OrderStatus.Active)
completed_orders = self.broker.get_orders(OrderStatus.Completed)

# 获取特定订单
order = self.broker.get_order(ref=123)

# 取消订单
self.broker.cancel_order(order)
```

## 八、调试和日志

### 1. 开启订单日志
```python
# 在策略配置中开启订单日志
config = Config()
config.islogorder = True  # 开启订单详细日志
```

### 2. 日志示例
```
[2024-01-15 09:30:00] 订单创建: Buy 10手 Limit at 3800
[2024-01-15 09:31:00] 订单成交: Buy 10手 at 3798.5
[2024-01-15 09:35:00] 订单完成: Buy 10手
```
<!-- ### 3. 订单调试工具
```python
class OrderDebugTool:
    """订单调试工具"""
    
    @staticmethod
    def print_order_details(order: Order):
        """打印订单详细信息"""
        print(f"\n=== 订单详细信息 ===")
        print(f"引用号: {order.ref}")
        print(f"方向: {OrderSide.get_name(order.side)}")
        print(f"手数: {order.size} (已成交: {order.executed_size})")
        print(f"类型: {OrderType.get_name(order.exectype)}")
        
        if order.price:
            print(f"价格: {order.price:.2f}")
        if order.pricelimit:
            print(f"限价: {order.pricelimit:.2f}")
        
        print(f"状态: {OrderStatus.get_name(order.status)}")
        
        if order.create_time:
            print(f"创建时间: {order.create_time}")
        if order.executed_datetime:
            print(f"成交时间: {order.executed_datetime}")
            print(f"成交价格: {order.executed_price:.2f}")
            print(f"成交金额: {order.executed_value:.2f}")
            print(f"手续费: {order.executed_commission:.2f}")
        
        if order.valid:
            print(f"有效期: {order.valid}")
        
        if order.info:
            print(f"自定义信息: {order.info}")
    
    @staticmethod
    def validate_order(order: Order) -> List[str]:
        """验证订单有效性，返回问题列表"""
        issues = []
        
        # 检查手数
        if order.size <= 0:
            issues.append("手数必须为正整数")
        
        # 检查价格
        if order.exectype in [OrderType.Limit, OrderType.Stop, OrderType.StopLimit]:
            if order.price is None or order.price <= 0:
                issues.append(f"{OrderType.get_name(order.exectype)}订单必须指定有效价格")
        
        # 检查有效期
        if order.valid is not None:
            if isinstance(order.valid, int) and order.valid < 0:
                issues.append("有效期不能为负数")
        
        return issues
``` -->
<!-- ## 九、性能优化建议

### 1. 批量订单处理
```python
# 批量处理订单，减少循环
self.broker.process_orders()
```

### 2. 订单状态缓存
```python
# 缓存活跃订单，避免频繁查询
self._cached_orders = {
    order.ref: order 
    for order in self.broker._active_orders
}
``` -->

## 九、常见问题解决

### 1. 订单不成交
- 检查价格是否合理
- 确认订单类型是否正确
- 验证资金是否充足

### 2. 订单状态异常
- 检查订单有效期
- 确认是否有关联的 OCO 订单
- 验证 Broker 是否正确处理订单

### 3. 实盘回测差异
- 确认手续费和滑点设置一致
- 检查订单执行逻辑差异
- 验证价格获取方式

## 总结

### MiniBT订单系统经过完善后，提供了：

1. **完整的订单生命周期管理**：从创建到完成的全程跟踪
2. **丰富的订单类型支持**：市价、限价、止损、止损限价等
3. **灵活的配置选项**：支持多种有效期、价格处理方式
4. **强大的分析工具**：订单统计、性能分析、调试工具
5. **良好的扩展性**：易于添加新的订单类型和功能

MiniBT 订单系统提供了一个强大而灵活的交易执行框架，既适用于回测研究，也支持实盘交易。通过统一的设计理念和丰富的功能支持，开发者可以专注于策略逻辑的实现，而无需过多关注底层交易细节。系统设计的模块化架构也便于后续的功能扩展和性能优化。