# minibt 内置指标 `rolling_apply` 函数完整用法详解
## 一、 基本用法（函数核心说明）
### 滚动窗口自定义函数计算（方法接口）
- 在滚动窗口上应用自定义函数，支持并行计算，结果自动转为框架内置指标对象
- 解决Pandas rolling.apply不支持多输出、效率低的问题，适用于复杂指标计算

### 核心优势
- 可变窗口支持：窗口大小可为整数（固定窗口）或序列（每个位置自定义窗口大小）
- 多输出支持：自定义函数可返回多个值（如同时计算均值、标准差），自动生成多线条指标
- 并行加速：通过n_jobs控制并行线程数，处理大规模数据时提升效率
- 类型兼容：自动适配一维（IndSeries）/多维（IndFrame）输入，返回对应类型的指标对象

### 参数说明
| 参数名            | 详细描述                                                                 |
|-------------------|--------------------------------------------------------------------------|
| `func (Callable)` | 应用于每个滚动窗口的自定义函数<br>- 输入：窗口内的数据（IndSeries→1D np.ndarray，IndFrame→2D np.ndarray或多参数1D数组）<br>- 输出：单个值或多个值（如返回(mean, std)生成两个线条） |
| `window (Union[int, pd.Series, np.ndarray, list[int]])` | 滚动窗口大小<br>- 整数：固定窗口大小（所有位置使用相同窗口）<br>- 序列类型（pd.Series/np.ndarray/list）：可变窗口大小（需满足：长度与主数据一致，且所有元素为正整数） |
| `prepend_nans (bool, optional)` | 滚动数组长度不足时是否在数组前填充NaN，默认True<br>- True：前window-1个滚动数组长度不足的在其前面填充NaN（默认，符合技术指标习惯）<br>- False：滚动数组无NaN值 |
| `n_jobs (int, optional)` | 并行计算的线程数，默认1<br>- 1：单线程（默认，避免线程开销）<br>- >1：多线程（需func线程安全，适合CPU密集型计算）<br>- -1：使用所有可用CPU核心 |
| `**kwargs`        | 扩展参数（如lines=[]指定线条名称、overlap=True设置主图叠加）             |

### 返回值
```
Union[IndFrame, IndSeries]:
    - IndSeries：func返回单个值时（1D结果）
    - IndFrame：func返回多个值时（2D结果）
```

### 基础示例详解
#### 1. 一维输入（IndSeries）→ 多输出（两个线条）
```python
# 自定义函数：计算窗口内收盘价的最小值和最大值
def calc_window_min_max(close: np.ndarray) -> tuple[float, float]:
    """
    close: 窗口内收盘价（1D np.ndarray，长度=window）
    返回：窗口内最小值、最大值
    """
    return close.min(), close.max()

# 调用rolling_apply：5日窗口，生成两个线条（"close_min"、"close_max"）
self.window_min_max = self.data.close.rolling_apply(
    func=calc_window_min_max,
    window=5,
    lines=["close_min", "close_max"],  # 指定线条名称
    overlap=True  # 主图叠加（与K线同图显示）
)
# 返回结果：IndFrame对象，含"close_min"和"close_max"两列
```

#### 2. 多维输入（IndFrame多列）→ 多输出（两个线条）
```python
# 自定义函数：计算窗口内最高价均值和最低价标准差（多参数输入）
def calc_high_mean_low_std(high: np.ndarray, low: np.ndarray, a: float = 1.) -> tuple[float, float]:
    """
    high：窗口内最高价（1D np.ndarray）
    low：窗口内最低价（1D np.ndarray）
    a：自定义参数（示例用，无实际意义）
    返回：最高价均值、最低价标准差
    """
    return high.mean(), low.std() * a

# 调用rolling_apply：3日窗口，指定输入列，生成两个线条
self.high_low_stats = self.data.rolling_apply(
    func=calc_high_mean_low_std,
    window=3,
    lines=["high_mean", "low_std"],  # 线条名称
    # 分别设置叠加（high_mean主图，low_std副图）
    overlap=dict(high_mean=True, low_std=False),
    a=2.  # 传递自定义参数a=2.
)
# 返回结果：IndFrame对象，含"high_mean"和"low_std"两列
```

#### 3. 多维输入（IndFrame）→ 多输出（两个线条，单参数接收）
```python
# 自定义函数：接收2D数组（所有列），计算均值和标准差
# 传递参数为IndFrame以window滚动的数组
def calc_df_mean_std(df: np.ndarray) -> tuple[float, float]:
    """
    df：窗口内所有列的数据（2D np.ndarray，形状=(window, 列数)）
    返回：所有元素的均值、所有元素的标准差
    """
    return df.mean(), df.std()

# 调用rolling_apply：3日窗口，输入OHLC四列
self.ohlc_stats = self.data.loc[:, FILED.OHLC].rolling_apply(
    func=calc_df_mean_std,
    window=3,
    lines=["ohlc_mean", "ohlc_std"],
    overlap=dict(ohlc_mean=True, ohlc_std=False)
)
# 返回结果：IndFrame对象，含"ohlc_mean"和"ohlc_std"两列
```

## 二、 补充实战示例
### 示例1：固定窗口用法 - LOWESS 局部加权散点平滑指标
该示例使用 `rolling_apply` 固定窗口实现 LOWESS 指标，演示多维输入（close+sigma）单输出的实战场景。

```python
import math
from minibt import *

class LOWESS(BtIndicator):
    """
    LOWESS 局部加权散点平滑指标
    对应：https://cn.tradingview.com/script/hyeoDyZn-LOWESS-Locally-Weighted-Scatterplot-Smoothing-ChartPrime/
    """
    params = dict(length=100, malen=100)
    overlap = True

    def next(self):
        length = self.params.length
        # 1. 准备多维输入数据（组装IndFrame）
        close = self.close.values
        atr = self.atr(length)
        std = self.close.stdev(length)
        sigma = (atr + std) / 2.
        sigma = sigma.values
        data = IndFrame(dict(close=close, sigma=sigma))

        # 2. 定义自定义滚动函数（按列接收多维参数）
        def func(close: np.ndarray, sigma: np.ndarray):
            close = close[::-1]  # 数据反转适配指标逻辑
            sigma = sigma[-1]    # 取窗口内sigma最后一个值
            gma = 0.
            sumOfWeights = 0.
            for i in range(length):
                h_l = close[:i+1]
                highest = h_l.max()
                lowest = h_l.min()
                # 高斯权重核心计算
                weight = math.exp(-math.pow(((i - (length - 1)) / (2 * sigma)), 2) / 2)
                value = highest + lowest
                gma = gma + (value * weight)
                sumOfWeights += weight

            return (gma / sumOfWeights) / 2.  # 单输出值，返回IndSeries

        # 3. 调用rolling_apply（固定窗口：length=100）
        GaussianMA = data.rolling_apply(func, length)

        # 4. 拓展：对结果进行二次滚动平滑（兼容Pandas rolling.apply）
        def lowess_smooth(src: pd.Series):
            length_src = len(src)
            src = src.values[::-1]
            sum_w = 0.0
            sum_wx = 0.0
            sum_wy = 0.0
            for i in range(length_src):
                # 立方平滑权重计算
                w = math.pow(1 - math.pow(i / length_src, 3), 3)
                sum_w += w
                sum_wx += w * i
                sum_wy += w * src[i]
            a = sum_wy / sum_w
            b = sum_wx / sum_w
            return a + b / (length_src - 1) / 2000.

        # 二次平滑：固定窗口 malen=100
        smoothed = GaussianMA.rolling(self.params.malen).apply(lowess_smooth)

        return GaussianMA, smoothed
```

### 示例2：可变窗口用法 - AdaptiveMA 自适应移动平均线
该示例使用 `rolling_apply` 可变窗口实现自适应移动平均线，根据市场波动率动态调整窗口大小，演示一维输入单输出的实战场景。

```python
import pandas as pd
from minibt import BtIndicator, Strategy, Bt, LocalDatas, Colors

class AdaptiveMA(BtIndicator):
    """
    自适应移动平均线（根据波动率调整窗口大小）
    """
    params = {
        "min_length": 5,
        "max_length": 50,
        "volatility_period": 20
    }
    overlap = True

    def next(self):
        # 1. 计算市场波动率
        volatility = self.close.rolling(self.params.volatility_period).std()

        # 2. 处理NaN值，避免计算异常
        vol_mean = volatility.mean()
        volatility = volatility.fillna(vol_mean if vol_mean > 0 else 1)

        # 3. 归一化波动率（映射到0~1区间）
        vol_min = volatility.min()
        vol_max = volatility.max()
        if vol_max - vol_min == 0:
            normalized_vol = pd.Series(0.5, index=volatility.index)
        else:
            normalized_vol = (volatility - vol_min) / (vol_max - vol_min)

        # 4. 生成可变窗口序列（pd.Series，长度与主数据一致）
        adaptive_length = (
            self.params.min_length +
            (self.params.max_length - self.params.min_length) * normalized_vol
        ).apply(lambda x: int(max(self.params.min_length, min(self.params.max_length, x))))

        # 5. 调用rolling_apply（可变窗口：adaptive_length）
        adaptive_ma = self.close.rolling_apply(
            func=lambda x: x.mean(),  # 简化函数：计算窗口均值
            window=adaptive_length,   # 传入可变窗口序列
            prepend_nans=True         # 保留默认NaN填充
        )

        return adaptive_ma

# 策略加载与运行
class MyStrategy(Strategy):
    def __init__(self):
        self.data = self.get_kline(LocalDatas.v2601_300)
        self.data.height = 500
        # 加载自适应移动平均线指标
        self.test = AdaptiveMA(self.data)
        self.test.line_width = 2
        self.test.line_color = Colors.blue

if __name__ == "__main__":
    Bt().run()
```


## 四、核心优势回顾（结合示例体现）
1.  **窗口灵活性**：支持固定窗口（示例1）和可变窗口（示例2），适配不同指标需求
2.  **类型兼容性**：输入支持 `IndSeries`/`IndFrame`，输出自动转为 `IndSeries`/`IndFrame`，可与 Pandas 滚动方法兼容（示例1二次平滑）
3.  **简化复杂计算**：无需手动处理窗口滑动和数据格式转换，专注于核心业务逻辑（两个示例均体现）
4.  **效率与扩展性**：支持并行计算（`n_jobs` 参数），支持多输出和额外参数传递，远超 Pandas 原生 `rolling.apply`

## 总结
1.  `rolling_apply` 是 minibt 用于复杂滚动指标计算的核心接口，核心解决 Pandas 原生方法的痛点；
2.  核心用法分 **固定窗口**（示例1，`window` 传整数）和 **可变窗口**（示例2，`window` 传序列）两大类；
3.  关键流程：准备 `IndSeries`/`IndFrame` 数据 → 定义自定义函数 → 传入窗口参数调用 → 获取框架内置指标结果；
4.  额外特性：支持多维输入、多输出、并行计算和额外参数传递，可灵活适配各类金融技术指标的实现需求。